{"mention": "TokyoX", "context_left": "", "context_right": ": DLL side-loading an unknown artifact", "_context_left": "", "_context_right": ": DLL side-loading an unknown artifact", "sentence_left": "", "sentence_right": "January 10, 2022", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "DLL side-loading an unknown artifact", "context_left": "TokyoX:", "context_right": "", "_context_left": "TokyoX: ", "_context_right": "", "sentence_left": "", "sentence_right": "January 10, 2022", "label": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution. There are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.", "label_id": 185, "label_title": "Hijack Execution Flow", "label_link": "https://attack.mitre.org/techniques/T1574", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "During Christmas holidays, Lab52 has been analyzing a sample which loads an artifact that we have decided to refer to as “", "context_right": "” since no similarities have been found as to any known malware, which we usually detect in open sources.", "_context_left": "During Christmas holidays, Lab52 has been analyzing a sample which loads an artifact that we have decided to refer to as “", "_context_right": "” since no similarities have been found as to any known malware, which we usually detect in open sources.", "sentence_left": "January 10, 2022", "sentence_right": "However, we cannot confirm so far that it is indeed a new family of malware.", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "PlugX", "context_left": "Some antivirus engines tagged the sample as", "context_right": ", but it seems that the attribution might be due to the final payload’s loading mechanism: DLL sideloading with an encrypted payload in the same directory.", "_context_left": "Some antivirus engines tagged the sample as ", "_context_right": ", but it seems that the attribution might be due to the final payload’s loading mechanism: DLL sideloading with an encrypted payload in the same directory.", "sentence_left": "Last Analysis 2021-12-23 23:38:08", "sentence_right": "After analyzing the final payload we could not find any similarities with other known samples from PlugX other than the loading TTPs.", "label": "[PlugX](https://attack.mitre.org/software/S0013) is a remote access tool (RAT) that uses modular plugins. It has been used by multiple threat groups. (Citation: Lastline PlugX Analysis) (Citation: FireEye Clandestine Fox Part 2) (Citation: New DragonOK) (Citation: Dell TG-3390)", "label_id": 861, "label_title": "PlugX", "label_link": "https://attack.mitre.org/software/S0013", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "DLL sideloading with an encrypted payload in the same directory", "context_left": "Some antivirus engines tagged the sample as PlugX, but it seems that the attribution might be due to the final payload’s loading mechanism:", "context_right": ".", "_context_left": "Some antivirus engines tagged the sample as PlugX, but it seems that the attribution might be due to the final payload’s loading mechanism: ", "_context_right": ".", "sentence_left": "Last Analysis 2021-12-23 23:38:08", "sentence_right": "After analyzing the final payload we could not find any similarities with other known samples from PlugX other than the loading TTPs.", "label": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution. There are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.", "label_id": 185, "label_title": "Hijack Execution Flow", "label_link": "https://attack.mitre.org/techniques/T1574", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "PlugX", "context_left": "After analyzing the final payload we could not find any similarities with other known samples from", "context_right": "other than the loading TTPs.", "_context_left": "After analyzing the final payload we could not find any similarities with other known samples from ", "_context_right": " other than the loading TTPs.", "sentence_left": "Some antivirus engines tagged the sample as PlugX, but it seems that the attribution might be due to the final payload’s loading mechanism: DLL sideloading with an encrypted payload in the same directory.", "sentence_right": "This DLL had a related .zip file with the name планирование.zip (translated to as planning.zip).", "label": "[PlugX](https://attack.mitre.org/software/S0013) is a remote access tool (RAT) that uses modular plugins. It has been used by multiple threat groups. (Citation: Lastline PlugX Analysis) (Citation: FireEye Clandestine Fox Part 2) (Citation: New DragonOK) (Citation: Dell TG-3390)", "label_id": 861, "label_title": "PlugX", "label_link": "https://attack.mitre.org/software/S0013", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "The legitimate file Creative.exe, an encrypted Data file and the version.dll DLL, which implements the loader function for the Data file, and therefore responsible of mapping the “", "context_right": "”.", "_context_left": "The legitimate file Creative.exe, an encrypted Data file and the version.dll DLL, which implements the loader function for the Data file, and therefore responsible of mapping the “", "_context_right": "”.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/00.png)", "sentence_right": "If we execute it from a path which is not final or the expected by the malware, it replicates to another path and executes from there, which is something it does have in common with some PlugX dll loaders:", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "PlugX", "context_left": "If we execute it from a path which is not final or the expected by the malware, it replicates to another path and executes from there, which is something it does have in common with some", "context_right": "dll loaders:", "_context_left": "If we execute it from a path which is not final or the expected by the malware, it replicates to another path and executes from there, which is something it does have in common with some ", "_context_right": " dll loaders:", "sentence_left": "The legitimate file Creative.exe, an encrypted Data file and the version.dll DLL, which implements the loader function for the Data file, and therefore responsible of mapping the “TokyoX”.", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/01.png)", "label": "[PlugX](https://attack.mitre.org/software/S0013) is a remote access tool (RAT) that uses modular plugins. It has been used by multiple threat groups. (Citation: Lastline PlugX Analysis) (Citation: FireEye Clandestine Fox Part 2) (Citation: New DragonOK) (Citation: Dell TG-3390)", "label_id": 861, "label_title": "PlugX", "label_link": "https://attack.mitre.org/software/S0013", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "dll loaders:", "context_left": "If we execute it from a path which is not final or the expected by the malware, it replicates to another path and executes from there, which is something it does have in common with some PlugX", "context_right": "", "_context_left": "If we execute it from a path which is not final or the expected by the malware, it replicates to another path and executes from there, which is something it does have in common with some PlugX ", "_context_right": "", "sentence_left": "The legitimate file Creative.exe, an encrypted Data file and the version.dll DLL, which implements the loader function for the Data file, and therefore responsible of mapping the “TokyoX”.", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/01.png)", "label": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution. There are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.", "label_id": 185, "label_title": "Hijack Execution Flow", "label_link": "https://attack.mitre.org/techniques/T1574", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe", "context_left": "Once executed, we observe how the", "context_right": "process tries to establish connections with port 443 of the IP address 31.192.107[.]187.", "_context_left": "Once executed, we observe how the ", "_context_right": " process tries to establish connections with port 443 of the IP address 31.192.107[.]187.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/01.png)", "sentence_right": "In this analysis we will focus on different aspects about the process; from double-clicking the binary 123.exe process (which is a copy of Creative.exe but in another path) to the execution of “TokyoX” already decrypted in memory.", "label": "[netsh](https://attack.mitre.org/software/S0108) is a scripting utility used to interact with networking components on local or remote systems. (Citation: TechNet Netsh)", "label_id": 636, "label_title": "netsh", "label_link": "https://attack.mitre.org/software/S0108", "entity_class": "CE", "entity_type": "TOOL", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe process tries to establish connections with port 443 of the IP address 31.192.107[.]187", "context_left": "Once executed, we observe how the", "context_right": ".", "_context_left": "Once executed, we observe how the ", "_context_right": ".", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/01.png)", "sentence_right": "In this analysis we will focus on different aspects about the process; from double-clicking the binary 123.exe process (which is a copy of Creative.exe but in another path) to the execution of “TokyoX” already decrypted in memory.", "label": "Adversaries may communicate using application layer protocols to avoid detection/network filtering by blending in with existing traffic. Commands to the remote system, and often the results of those commands, will be embedded within the protocol traffic between the client and server. Adversaries may utilize many different protocols, including those used for web browsing, transferring files, electronic mail, or DNS. For connections that occur internally within an enclave (such as those between a proxy or pivot node and other nodes), commonly used protocols are SMB, SSH, or RDP.", "label_id": 452, "label_title": "Application Layer Protocol", "label_link": "https://attack.mitre.org/techniques/T1071", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "from double-clicking the binary 123.exe process", "context_left": "In this analysis we will focus on different aspects about the process;", "context_right": "(which is a copy of Creative.exe but in another path) to the execution of “TokyoX” already decrypted in memory.", "_context_left": "In this analysis we will focus on different aspects about the process; ", "_context_right": " (which is a copy of Creative.exe but in another path) to the execution of “TokyoX” already decrypted in memory.", "sentence_left": "Once executed, we observe how the netsh.exe process tries to establish connections with port 443 of the IP address 31.192.107[.]187.", "sentence_right": "The first thing we observe within the process is how the version.dll library prepares the decryption and the final payload’s loading in the remote process:", "label": "An adversary may rely upon specific actions by a user in order to gain execution. Users may be subjected to social engineering to get them to execute malicious code by, for example, opening a malicious document file or link. These user actions will typically be observed as follow-on behavior from forms of [Phishing](https://attack.mitre.org/techniques/T1566). While [User Execution](https://attack.mitre.org/techniques/T1204) frequently occurs shortly after Initial Access it may occur at other phases of an intrusion, such as when an adversary places a file in a shared directory or on a user's desktop hoping that a user will click on it. This activity may also be seen shortly after [Internal Spearphishing](https://attack.mitre.org/techniques/T1534).", "label_id": 260, "label_title": "User Execution", "label_link": "https://attack.mitre.org/techniques/T1204", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "In this analysis we will focus on different aspects about the process; from double-clicking the binary 123.exe process (which is a copy of Creative.exe but in another path) to the execution of “", "context_right": "” already decrypted in memory.", "_context_left": "In this analysis we will focus on different aspects about the process; from double-clicking the binary 123.exe process (which is a copy of Creative.exe but in another path) to the execution of “", "_context_right": "” already decrypted in memory.", "sentence_left": "Once executed, we observe how the netsh.exe process tries to establish connections with port 443 of the IP address 31.192.107[.]187.", "sentence_right": "The first thing we observe within the process is how the version.dll library prepares the decryption and the final payload’s loading in the remote process:", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "decrypted", "context_left": "In this analysis we will focus on different aspects about the process; from double-clicking the binary 123.exe process (which is a copy of Creative.exe but in another path) to the execution of “TokyoX” already", "context_right": "in memory.", "_context_left": "In this analysis we will focus on different aspects about the process; from double-clicking the binary 123.exe process (which is a copy of Creative.exe but in another path) to the execution of “TokyoX” already ", "_context_right": " in memory.", "sentence_left": "Once executed, we observe how the netsh.exe process tries to establish connections with port 443 of the IP address 31.192.107[.]187.", "sentence_right": "The first thing we observe within the process is how the version.dll library prepares the decryption and the final payload’s loading in the remote process:", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe", "context_left": "After reading the file from disk, a child process", "context_right": "is created.", "_context_left": "After reading the file from disk, a child process ", "_context_right": " is created.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/03.png)", "sentence_right": "This just-created child process is where several new memory segments will be located (a total of 5, including the final decrypted payload) to decrypt the final “TokyoX” payload.", "label": "[netsh](https://attack.mitre.org/software/S0108) is a scripting utility used to interact with networking components on local or remote systems. (Citation: TechNet Netsh)", "label_id": 636, "label_title": "netsh", "label_link": "https://attack.mitre.org/software/S0108", "entity_class": "CE", "entity_type": "TOOL", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "final decrypted payload", "context_left": "This just-created child process is where several new memory segments will be located (a total of 5, including the", "context_right": ") to decrypt the final “TokyoX” payload.", "_context_left": "This just-created child process is where several new memory segments will be located (a total of 5, including the ", "_context_right": ") to decrypt the final “TokyoX” payload.", "sentence_left": "After reading the file from disk, a child process netsh.exe is created.", "sentence_right": "The APIs which were observed for the creation and writing of the remote process are the native APIs NtAllocateVirtualmemory and NtwriteVirtualmemory.", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "to decrypt the final “TokyoX” payload", "context_left": "This just-created child process is where several new memory segments will be located (a total of 5, including the final decrypted payload)", "context_right": ".", "_context_left": "This just-created child process is where several new memory segments will be located (a total of 5, including the final decrypted payload) ", "_context_right": ".", "sentence_left": "After reading the file from disk, a child process netsh.exe is created.", "sentence_right": "The APIs which were observed for the creation and writing of the remote process are the native APIs NtAllocateVirtualmemory and NtwriteVirtualmemory.", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "and another one of 4Kb. In the 4Kb segment we observe how the following string is set (which will be the string used for the decrypting process):", "context_left": "First, it creates two segments: 100Kb where the encrypted payload is located and which comes from the disc,", "context_right": "", "_context_left": "First, it creates two segments: 100Kb where the encrypted payload is located and which comes from the disc, ", "_context_right": "", "sentence_left": "The APIs which were observed for the creation and writing of the remote process are the native APIs NtAllocateVirtualmemory and NtwriteVirtualmemory.", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/04-1024x292.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "other memory segment of 100Kb contains", "context_left": "The", "context_right": "the following (encrypted content, as we see how it matches the content from Data file on Disk):", "_context_left": "The ", "_context_right": " the following (encrypted content, as we see how it matches the content from Data file on Disk):", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/04-1024x292.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/05-1024x784.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "the creation of these two segments, a third segment is allocated, where it is loaded the", "context_left": "After", "context_right": "absolute memory addresses from several win32 APIs (VirtualAlloc, LoadLibrary, GetProcAddress, the home address of the coded payload, etc.for its later use by the loader:", "_context_left": "After ", "_context_right": " absolute memory addresses from several win32 APIs (VirtualAlloc, LoadLibrary, GetProcAddress, the home address of the coded payload, etc.for its later use by the loader:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/05-1024x784.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/06.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "absolute memory addresses from several win32 APIs (VirtualAlloc, LoadLibrary, GetProcAddress,", "context_left": "After the creation of these two segments, a third segment is allocated, where it is loaded the", "context_right": "the home address of the coded payload, etc.for its later use by the loader:", "_context_left": "After the creation of these two segments, a third segment is allocated, where it is loaded the ", "_context_right": " the home address of the coded payload, etc.for its later use by the loader:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/05-1024x784.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/06.png)", "label": "Adversaries may execute malicious payloads via loading shared modules. The Windows module loader can be instructed to load DLLs from arbitrary local paths and arbitrary Universal Naming Convention (UNC) network paths. This functionality resides in NTDLL.dll and is part of the Windows [Native API](https://attack.mitre.org/techniques/T1106) which is called from functions like <code>CreateProcess</code>, <code>LoadLibrary</code>, etc. of the Win32 API. (Citation: Wikipedia Windows Library Files) The module loader can load DLLs: * via specification of the (fully-qualified or relative) DLL pathname in the IMPORT directory; * via EXPORT forwarded to another DLL, specified with (fully-qualified or relative) pathname (but without extension); * via an NTFS junction or symlink program.exe.local with the fully-qualified or relative pathname of a directory containing the DLLs specified in the IMPORT directory or forwarded EXPORTs; * via <code>&#x3c;file name=\"filename.extension\" loadFrom=\"fully-qualified or relative pathname\"&#x3e;</code> in an embedded or external \"application manifest\". The file name refers to an entry in the IMPORT directory or a forwarded EXPORT. Adversaries may use this functionality as a way to execute arbitrary payloads on a victim system. For example, malware may execute share modules to load additional components or features.", "label_id": 342, "label_title": "Shared Modules", "label_link": "https://attack.mitre.org/techniques/T1129", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "segment will have the memory addresses", "context_left": "We can notice how the", "context_right": "(starting from 123.exe they are located in netsh.exe segment through the version.dll code):", "_context_left": "We can notice how the ", "_context_right": " (starting from 123.exe they are located in netsh.exe segment through the version.dll code):", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/06.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/07-1024x131.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "they are located in netsh.exe segment through the version.dll code):", "context_left": "We can notice how the segment will have the memory addresses (starting from 123.exe", "context_right": "", "_context_left": "We can notice how the segment will have the memory addresses (starting from 123.exe ", "_context_right": "", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/06.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/07-1024x131.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "decrypt", "context_left": "Then, another segment of 4Kb is created where it loads the code that will", "context_right": "and load the final payload.", "_context_left": "Then, another segment of 4Kb is created where it loads the code that will ", "_context_right": " and load the final payload.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/07-1024x131.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/08.png)", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "another segment of 4Kb is created where it loads the code that will decrypt and load the final payload", "context_left": "Then,", "context_right": ".", "_context_left": "Then, ", "_context_right": ".", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/07-1024x131.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/08.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "Finally, the “", "context_right": "” loader runs from the DLL (version.dll) in netsh.exe through the API NtcreateThreadEx and we see the start of the last page created in the stack:", "_context_left": "Finally, the “", "_context_right": "” loader runs from the DLL (version.dll) in netsh.exe through the API NtcreateThreadEx and we see the start of the last page created in the stack:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/08.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/09-1024x476.png)", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe", "context_left": "Finally, the “TokyoX” loader runs from the DLL (version.dll) in", "context_right": "through the API NtcreateThreadEx and we see the start of the last page created in the stack:", "_context_left": "Finally, the “TokyoX” loader runs from the DLL (version.dll) in ", "_context_right": " through the API NtcreateThreadEx and we see the start of the last page created in the stack:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/08.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/09-1024x476.png)", "label": "[netsh](https://attack.mitre.org/software/S0108) is a scripting utility used to interact with networking components on local or remote systems. (Citation: TechNet Netsh)", "label_id": 636, "label_title": "netsh", "label_link": "https://attack.mitre.org/software/S0108", "entity_class": "CE", "entity_type": "TOOL", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "loader runs from the DLL (version.dll) in netsh.exe through the API NtcreateThreadEx", "context_left": "Finally, the “TokyoX”", "context_right": "and we see the start of the last page created in the stack:", "_context_left": "Finally, the “TokyoX” ", "_context_right": " and we see the start of the last page created in the stack:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/08.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/09-1024x476.png)", "label": "Adversaries may execute malicious payloads via loading shared modules. The Windows module loader can be instructed to load DLLs from arbitrary local paths and arbitrary Universal Naming Convention (UNC) network paths. This functionality resides in NTDLL.dll and is part of the Windows [Native API](https://attack.mitre.org/techniques/T1106) which is called from functions like <code>CreateProcess</code>, <code>LoadLibrary</code>, etc. of the Win32 API. (Citation: Wikipedia Windows Library Files) The module loader can load DLLs: * via specification of the (fully-qualified or relative) DLL pathname in the IMPORT directory; * via EXPORT forwarded to another DLL, specified with (fully-qualified or relative) pathname (but without extension); * via an NTFS junction or symlink program.exe.local with the fully-qualified or relative pathname of a directory containing the DLLs specified in the IMPORT directory or forwarded EXPORTs; * via <code>&#x3c;file name=\"filename.extension\" loadFrom=\"fully-qualified or relative pathname\"&#x3e;</code> in an embedded or external \"application manifest\". The file name refers to an entry in the IMPORT directory or a forwarded EXPORT. Adversaries may use this functionality as a way to execute arbitrary payloads on a victim system. For example, malware may execute share modules to load additional components or features.", "label_id": 342, "label_title": "Shared Modules", "label_link": "https://attack.mitre.org/techniques/T1129", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe", "context_left": "After the execution of NtCreateThreadEx, as indicated, the loader is initiated in", "context_right": "in the segment:", "_context_left": "After the execution of NtCreateThreadEx, as indicated, the loader is initiated in ", "_context_right": " in the segment:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/09-1024x476.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/10.png)", "label": "[netsh](https://attack.mitre.org/software/S0108) is a scripting utility used to interact with networking components on local or remote systems. (Citation: TechNet Netsh)", "label_id": 636, "label_title": "netsh", "label_link": "https://attack.mitre.org/software/S0108", "entity_class": "CE", "entity_type": "TOOL", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "the loader is initiated in netsh.exe in the segment:", "context_left": "After the execution of NtCreateThreadEx, as indicated,", "context_right": "", "_context_left": "After the execution of NtCreateThreadEx, as indicated, ", "_context_right": "", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/09-1024x476.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/10.png)", "label": "Adversaries may establish persistence and/or elevate privileges using system mechanisms that trigger execution based on specific events. Various operating systems have means to monitor and subscribe to events such as logons or other user activity such as running specific applications/binaries. Adversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via repeatedly executing malicious code. After gaining access to a victim system, adversaries may create/modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked.(Citation: FireEye WMI 2015)(Citation: Malware Persistence on OS X)(Citation: amnesia malware) Since the execution can be proxied by an account with higher permissions, such as SYSTEM or service accounts, an adversary may be able to abuse these triggered execution mechanisms to escalate their privileges.", "label_id": 472, "label_title": "Event Triggered Execution", "label_link": "https://attack.mitre.org/techniques/T1546", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe", "context_left": "Once the execution is moved to the", "context_right": "process, it takes the string located in the initial 4Kb segment, copies it into the stack and replicates it (0x100, 256 bytes) to match the specific block size of 256bytes.", "_context_left": "Once the execution is moved to the ", "_context_right": " process, it takes the string located in the initial 4Kb segment, copies it into the stack and replicates it (0x100, 256 bytes) to match the specific block size of 256bytes.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/10.png)", "sentence_right": "In the following screenshots we can observe how the block ends with the string “!Up.", "label": "[netsh](https://attack.mitre.org/software/S0108) is a scripting utility used to interact with networking components on local or remote systems. (Citation: TechNet Netsh)", "label_id": 636, "label_title": "netsh", "label_link": "https://attack.mitre.org/software/S0108", "entity_class": "CE", "entity_type": "TOOL", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "execution is moved to the netsh.exe process", "context_left": "Once the", "context_right": ", it takes the string located in the initial 4Kb segment, copies it into the stack and replicates it (0x100, 256 bytes) to match the specific block size of 256bytes.", "_context_left": "Once the ", "_context_right": ", it takes the string located in the initial 4Kb segment, copies it into the stack and replicates it (0x100, 256 bytes) to match the specific block size of 256bytes.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/10.png)", "sentence_right": "In the following screenshots we can observe how the block ends with the string “!Up.", "label": "Adversaries may establish persistence and/or elevate privileges using system mechanisms that trigger execution based on specific events. Various operating systems have means to monitor and subscribe to events such as logons or other user activity such as running specific applications/binaries. Adversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via repeatedly executing malicious code. After gaining access to a victim system, adversaries may create/modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked.(Citation: FireEye WMI 2015)(Citation: Malware Persistence on OS X)(Citation: amnesia malware) Since the execution can be proxied by an account with higher permissions, such as SYSTEM or service accounts, an adversary may be able to abuse these triggered execution mechanisms to escalate their privileges.", "label_id": 472, "label_title": "Event Triggered Execution", "label_link": "https://attack.mitre.org/techniques/T1546", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "copies it into the stack and replicates it", "context_left": "Once the execution is moved to the netsh.exe process, it takes the string located in the initial 4Kb segment,", "context_right": "(0x100, 256 bytes) to match the specific block size of 256bytes.", "_context_left": "Once the execution is moved to the netsh.exe process, it takes the string located in the initial 4Kb segment, ", "_context_right": " (0x100, 256 bytes) to match the specific block size of 256bytes.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/10.png)", "sentence_right": "In the following screenshots we can observe how the block ends with the string “!Up.", "label": "Adversaries may reflectively load code into a process in order to conceal the execution of malicious payloads. Reflective loading involves allocating then executing payloads directly within the memory of the process, vice creating a thread or process backed by a file path on disk. Reflectively loaded payloads may be compiled binaries, anonymous files (only present in RAM), or just snubs of fileless executable code (ex: position-independent shellcode).(Citation: Introducing Donut)(Citation: S1 Custom Shellcode Tool)(Citation: Stuart ELF Memory)(Citation: 00sec Droppers)(Citation: Mandiant BYOL) Reflective code injection is very similar to [Process Injection](https://attack.mitre.org/techniques/T1055) except that the “injection” loads code into the processes’ own memory instead of that of a separate process. Reflective loading may evade process-based detections since the execution of the arbitrary code may be masked within a legitimate or otherwise benign process. Reflectively loading payloads directly into memory may also avoid creating files or other artifacts on disk, while also enabling malware to keep these payloads encrypted (or otherwise obfuscated) until execution.(Citation: Stuart ELF Memory)(Citation: 00sec Droppers)(Citation: Intezer ACBackdoor)(Citation: S1 Old Rat New Tricks)", "label_id": 501, "label_title": "Reflective Code Loading", "label_link": "https://attack.mitre.org/techniques/T1620", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "results in the following block in memory", "context_left": "The combination of the blue block (in following image) and the 00-FF block (pointed in red in previous image)", "context_right": ", marked in red in the image:", "_context_left": "The combination of the blue block (in following image) and the 00-FF block (pointed in red in previous image) ", "_context_right": ", marked in red in the image:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/14.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/15.png)", "label": "Adversaries may reflectively load code into a process in order to conceal the execution of malicious payloads. Reflective loading involves allocating then executing payloads directly within the memory of the process, vice creating a thread or process backed by a file path on disk. Reflectively loaded payloads may be compiled binaries, anonymous files (only present in RAM), or just snubs of fileless executable code (ex: position-independent shellcode).(Citation: Introducing Donut)(Citation: S1 Custom Shellcode Tool)(Citation: Stuart ELF Memory)(Citation: 00sec Droppers)(Citation: Mandiant BYOL) Reflective code injection is very similar to [Process Injection](https://attack.mitre.org/techniques/T1055) except that the “injection” loads code into the processes’ own memory instead of that of a separate process. Reflective loading may evade process-based detections since the execution of the arbitrary code may be masked within a legitimate or otherwise benign process. Reflectively loading payloads directly into memory may also avoid creating files or other artifacts on disk, while also enabling malware to keep these payloads encrypted (or otherwise obfuscated) until execution.(Citation: Stuart ELF Memory)(Citation: 00sec Droppers)(Citation: Intezer ACBackdoor)(Citation: S1 Old Rat New Tricks)", "label_id": 501, "label_title": "Reflective Code Loading", "label_link": "https://attack.mitre.org/techniques/T1620", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "stores the absolute addresses to different API from Win32", "context_left": "On the next step, the loader reads the initial argument, arg0, whose value is 0x900000 and points at the 4Kb block, which", "context_right": ":", "_context_left": "On the next step, the loader reads the initial argument, arg0, whose value is 0x900000 and points at the 4Kb block, which ", "_context_right": ":", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/15.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/16.png)", "label": "Adversaries may execute malicious payloads via loading shared modules. The Windows module loader can be instructed to load DLLs from arbitrary local paths and arbitrary Universal Naming Convention (UNC) network paths. This functionality resides in NTDLL.dll and is part of the Windows [Native API](https://attack.mitre.org/techniques/T1106) which is called from functions like <code>CreateProcess</code>, <code>LoadLibrary</code>, etc. of the Win32 API. (Citation: Wikipedia Windows Library Files) The module loader can load DLLs: * via specification of the (fully-qualified or relative) DLL pathname in the IMPORT directory; * via EXPORT forwarded to another DLL, specified with (fully-qualified or relative) pathname (but without extension); * via an NTFS junction or symlink program.exe.local with the fully-qualified or relative pathname of a directory containing the DLLs specified in the IMPORT directory or forwarded EXPORTs; * via <code>&#x3c;file name=\"filename.extension\" loadFrom=\"fully-qualified or relative pathname\"&#x3e;</code> in an embedded or external \"application manifest\". The file name refers to an entry in the IMPORT directory or a forwarded EXPORT. Adversaries may use this functionality as a way to execute arbitrary payloads on a victim system. For example, malware may execute share modules to load additional components or features.", "label_id": 342, "label_title": "Shared Modules", "label_link": "https://attack.mitre.org/techniques/T1129", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "decrypting process for the final payload", "context_left": "After this, the", "context_right": "begins.", "_context_left": "After this, the ", "_context_right": " begins.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/16.png)", "sentence_right": "The decrypting process gets two values from the second block, exchanges and adds them, and the result serves as a final index to recover the element from the second block with which the xor will be achieved through the coded block.", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "decrypting process", "context_left": "The", "context_right": "gets two values from the second block, exchanges and adds them, and the result serves as a final index to recover the element from the second block with which the xor will be achieved through the coded block.", "_context_left": "The ", "_context_right": " gets two values from the second block, exchanges and adds them, and the result serves as a final index to recover the element from the second block with which the xor will be achieved through the coded block.", "sentence_left": "After this, the decrypting process for the final payload begins.", "sentence_right": "This description of the decryption algorythm has been identified as the **RC4 algorythm**.", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "exchanges and adds them, and the result serves as a final index to recover the element from the second block with which the xor will be achieved through the coded block.", "context_left": "The decrypting process gets two values from the second block,", "context_right": "", "_context_left": "The decrypting process gets two values from the second block, ", "_context_right": "", "sentence_left": "After this, the decrypting process for the final payload begins.", "sentence_right": "This description of the decryption algorythm has been identified as the **RC4 algorythm**.", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "This description of the decryption algorythm has been identified as the **RC4 algorythm", "context_left": "", "context_right": "**.", "_context_left": "", "_context_right": "**.", "sentence_left": "The decrypting process gets two values from the second block, exchanges and adds them, and the result serves as a final index to recover the element from the second block with which the xor will be achieved through the coded block.", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/17.png)", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "PE binary", "context_left": "After the decryption process, we find a", "context_right": ", as seen in the following image.", "_context_left": "After the decryption process, we find a ", "_context_right": ", as seen in the following image.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/17.png)", "sentence_right": "In this case, the payload does not start with the traditional MZ header but the string “tokyo”:", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "decryption process", "context_left": "After the", "context_right": ", we find a PE binary, as seen in the following image.", "_context_left": "After the ", "_context_right": ", we find a PE binary, as seen in the following image.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/17.png)", "sentence_right": "In this case, the payload does not start with the traditional MZ header but the string “tokyo”:", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "netsh.exe", "context_left": "This creates another memory segment in the process", "context_right": "with RWX licenses (that of 116Kb) which will be used to load the PE:", "_context_left": "This creates another memory segment in the process ", "_context_right": " with RWX licenses (that of 116Kb) which will be used to load the PE:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/Screenshot-from-2022-01-10-16-37-59-1024x307.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/20-1024x89.png)", "label": "[netsh](https://attack.mitre.org/software/S0108) is a scripting utility used to interact with networking components on local or remote systems. (Citation: TechNet Netsh)", "label_id": 636, "label_title": "netsh", "label_link": "https://attack.mitre.org/software/S0108", "entity_class": "CE", "entity_type": "TOOL", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "used to load the PE", "context_left": "This creates another memory segment in the process netsh.exe with RWX licenses (that of 116Kb) which will be", "context_right": ":", "_context_left": "This creates another memory segment in the process netsh.exe with RWX licenses (that of 116Kb) which will be ", "_context_right": ":", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/Screenshot-from-2022-01-10-16-37-59-1024x307.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/20-1024x89.png)", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "Windows PE", "context_left": "In this new segment, it maps the binary using the virtual addresses as the regular", "context_right": "loader would do.", "_context_left": "In this new segment, it maps the binary using the virtual addresses as the regular ", "_context_right": " loader would do.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/20-1024x89.png)", "sentence_right": "Then, it calls the API LoadLibraryA (it has the address since the DLL saved it in the memory segment) of the strings located in the mapped block:", "label": "Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process. There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific. More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.", "label_id": 318, "label_title": "Process Injection", "label_link": "https://attack.mitre.org/techniques/T1055", "entity_class": "CI", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "decrypted", "context_left": "After the correct mapping and having loaded the necessary libraries for its proper functioning, it calls EAX to run the", "context_right": "and mapped payload:", "_context_left": "After the correct mapping and having loaded the necessary libraries for its proper functioning, it calls EAX to run the ", "_context_right": " and mapped payload:", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/24.png)", "sentence_right": "![](https://lab52.io/blog/wp-content/uploads/2022/01/25-1024x452.png)", "label": "Adversaries may use [Obfuscated Files or Information](https://attack.mitre.org/techniques/T1027) to hide artifacts of an intrusion from analysis. They may require separate mechanisms to decode or deobfuscate that information depending on how they intend to use it. Methods for doing that include built-in functionality of malware or by using utilities present on the system. One such example is use of [certutil](https://attack.mitre.org/software/S0160) to decode a remote access tool portable executable file that has been hidden inside a certificate file. (Citation: Malwarebytes Targeted Attack against Saudi Arabia) Another example is using the Windows <code>copy /b</code> command to reassemble binary fragments into a malicious payload. (Citation: Carbon Black Obfuscation Sept 2016) Sometimes a user's action may be required to open it for deobfuscation or decryption as part of [User Execution](https://attack.mitre.org/techniques/T1204). The user may also be required to input a password to open a password protected compressed/encrypted file that was provided by the adversary. (Citation: Volexity PowerDuke November 2016)", "label_id": 514, "label_title": "Deobfuscate/Decode Files or Information", "label_link": "https://attack.mitre.org/techniques/T1140", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "To summarize, this article goes through the process followed in memory after executing the Creative Cloud application until deploying", "context_right": "in memory.", "_context_left": "To summarize, this article goes through the process followed in memory after executing the Creative Cloud application until deploying ", "_context_right": " in memory.", "sentence_left": "![](https://lab52.io/blog/wp-content/uploads/2022/01/26.png)", "sentence_right": "This DLL sideloading style is often linked to APT groups whose attribution is also linked to China, however being a known technique as it is, we are not able to consider any feasible attribution at the moment.", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "DLL sideloading style", "context_left": "This", "context_right": "is often linked to APT groups whose attribution is also linked to China, however being a known technique as it is, we are not able to consider any feasible attribution at the moment.", "_context_left": "This ", "_context_right": " is often linked to APT groups whose attribution is also linked to China, however being a known technique as it is, we are not able to consider any feasible attribution at the moment.", "sentence_left": "To summarize, this article goes through the process followed in memory after executing the Creative Cloud application until deploying TokyoX in memory.", "sentence_right": "As reviewed at the beginning of the article, what we have named as “TokyoX” has not been identified as a known malware so far (at least, with the sources that we have).", "label": "Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution. There are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.", "label_id": 185, "label_title": "Hijack Execution Flow", "label_link": "https://attack.mitre.org/techniques/T1574", "entity_class": "CE", "entity_type": "TECHNIQUE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "As reviewed at the beginning of the article, what we have named as “", "context_right": "” has not been identified as a known malware so far (at least, with the sources that we have).", "_context_left": "As reviewed at the beginning of the article, what we have named as “", "_context_right": "” has not been identified as a known malware so far (at least, with the sources that we have).", "sentence_left": "This DLL sideloading style is often linked to APT groups whose attribution is also linked to China, however being a known technique as it is, we are not able to consider any feasible attribution at the moment.", "sentence_right": "Additionally, at some point of the analysis we identified a tool used by this group for the creation of version.dll, which pretends to be a Windows DLL located in SysWOW/System32.", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}
{"mention": "TokyoX", "context_left": "Read the second part of the analysis of the final “", "context_right": "” RAT and its capacities [here](https://lab52.io/blog/tokyox-dll-side-loading-an-unknown-artifact-part-2/).", "_context_left": "Read the second part of the analysis of the final “", "_context_right": "” RAT and its capacities [here](https://lab52.io/blog/tokyox-dll-side-loading-an-unknown-artifact-part-2/).", "sentence_left": "Even though the exported functions are not shown in the previous image, we can appreciate how there is a perfect match between both snippets.", "sentence_right": "**IOCs**", "label": "TokyoX", "label_id": 1279, "label_title": "TokyoX", "label_link": "http://www.bosch.com#node1fvup9pj1x39", "entity_class": "CE", "entity_type": "MALWARE", "document": "lab52_2022-01-10_tokyox-dll-side-loading-an"}